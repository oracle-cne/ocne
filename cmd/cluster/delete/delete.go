// Copyright (c) 2024, Oracle and/or its affiliates.
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

package delete

import (
	"github.com/oracle-cne/ocne/cmd/constants"
	"github.com/oracle-cne/ocne/pkg/cluster/cache"
	"github.com/oracle-cne/ocne/pkg/cmdutil"
	delete2 "github.com/oracle-cne/ocne/pkg/commands/cluster/delete"
	config2 "github.com/oracle-cne/ocne/pkg/config"
	"github.com/oracle-cne/ocne/pkg/config/types"
	pkgconst "github.com/oracle-cne/ocne/pkg/constants"
	"github.com/spf13/cobra"
)

const (
	CommandName = "delete"
	helpShort   = "Destroy a cluster"
	helpLong    = `Destroy a cluster that has been deployed using ocne cluster start. This command only applies to clusters that have been created using local virtualization. 
It cannot be used to destroy clusters deployed to bare metal systems, pre-provisioned compute, or deployed using infrastructure automation APIs`
	helpExample = `
ocne cluster rm --config example-path/config
`
)

const (
	flagConfig      = "config"
	flagConfigShort = "c"
	flagConfigHelp  = "The path to a configuration file that contains the definition of the cluster to delete. If this value is not provided, it will destroy the small cluster that was generated by `ocne` `start` when run with no configuration file"
)

var clusterConfigPath string

var options delete2.DeleteOptions = delete2.DeleteOptions{
	Config:        &types.Config{},
	ClusterConfig: &types.ClusterConfig{},
}

func NewCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   CommandName,
		Short: helpShort,
		Long:  helpLong,
		Args:  cobra.MatchAll(cobra.ExactArgs(0), cobra.OnlyValidArgs),
	}

	cmd.RunE = func(cmd *cobra.Command, args []string) error {
		return RunCmd(cmd)
	}
	cmd.Example = helpExample
	cmdutil.SilenceUsage(cmd)

	cmd.Flags().StringVarP(&options.KubeConfigPath, constants.FlagKubeconfig, constants.FlagKubeconfigShort, "", constants.FlagKubeconfigHelp)
	cmd.Flags().StringVarP(&clusterConfigPath, flagConfig, flagConfigShort, "", flagConfigHelp)
	cmd.Flags().StringVarP(&options.SessionURI, constants.FlagSshURI, constants.FlagSshURIShort, "", constants.FlagSshURIHelp)
	cmd.Flags().StringVarP(&options.Name, constants.FlagClusterName, constants.FlagClusterNameShort, "", constants.FlagClusterNameHelp)
	cmd.Flags().StringVarP(&options.Provider, constants.FlagProviderName, constants.FlagProviderNameShort, "", constants.FlagProviderNameHelp)

	return cmd
}

// RunCmd runs the "ocne cluster rm" command
func RunCmd(cmd *cobra.Command) error {
	populateConfigurationFromCommandLine(&options)
	clusterCache, err := cache.GetCache()
	if err != nil {
		return err
	}
	var cc *types.ClusterConfig
	clusterName := options.ClusterConfig.Name

	// If a cluster config file has been passed, load it up.
	// This is done to get the cluster name.
	if clusterConfigPath != "" {
		cc, err = config2.ParseClusterConfigFile(clusterConfigPath)
		if err != nil {
			return err
		}

		clusterName = cc.Name
	}

	var cached *cache.Cluster
	if clusterName != nil {
		cached = clusterCache.Get(*clusterName)
	}

	// If the cluster does not exist, fall back to the CLI options.
	// This is a bail-out to make sure all the needful can be done in
	// case of some poorly timed error.
	if cached == nil {
		cc, err = cmdutil.GetFullConfig(options.ClusterConfig, clusterConfigPath)
		if err != nil {
			return err
		}
	} else {
		cc, err = cmdutil.GetFullConfig(&cached.ClusterConfig, "")
		if err != nil {
			return err
		}
	}

	if *cc.Name == "" {
		*cc.Name = "ocne"
	}
	if *cc.Provider == "" {
		*cc.Provider = pkgconst.ProviderTypeLibvirt
	}

	err = delete2.Delete(cc)
	return err
}

func populateConfigurationFromCommandLine(options *delete2.DeleteOptions) {
	if options.Name != "" {
		options.ClusterConfig.Name = &options.Name
	}
	if options.KubeConfigPath != "" {
		options.ClusterConfig.KubeConfig = &options.KubeConfigPath
	}
	if options.SessionURI != "" {
		options.ClusterConfig.Providers.Libvirt.SessionURI = &options.SessionURI
	}
	if options.Provider != "" {
		options.ClusterConfig.Provider = &options.Provider
	}

}
